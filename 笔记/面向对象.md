# 面向对象

## 简述

什么是对象？

万物皆对象，java中通过类来描述对象

```
/**
 * 类：解释面向对象
 *      定义类来定义一个群体
 * 对象：实例，一个群体中的个体
 * 方法：定义行为
 */
public class People {
    //特征或属性
    String eye; //默认值为 null ，int类型的默认值是 0；
    String nose;
    String hand;
    String name;
    int age;
    // 行为 - 》方法定义
    void sleep(){
        System.out.println("睡觉");
    }
    void eat(){
        System.out.println("吃饭");
    }
    void study(){
        System.out.println("学习");
    }
```

**String	：默认值是null；int	：是 0；double	：是0.0**

```java
/**
     *  主类：包含main方法
     */
    public static void main(String[] args) {
        //  new新建，p : 实例/对象
        //凡是new出来的东西，都在堆里，存储的是地址，
        People p = new People();
        //访问具体的属性/特征：对象名、属性
        p.age = 22;
        p.name = "WQH";
        //调用方法：对象名。方法名()
        p.sleep();
    }
```

## 构造器

**用来创建对象的，并且完成初始化**；可以初始化一些敏感的信息

```
People p = new People();	//new后面表示构造器，无参数：表示空构造器，类中默认提供
```

**People()**	：new后面表示构造器，无参数：表示空构造器，类中默认提供

```java
//默认提供空构造器
//相当于无参构造：public 类名(参数){}
public People(){
}
//有参构造器 -》创建对象
//如果有参构造器存在，则默认构造器不提供
//注意参数的传递顺序，以及参数类型要一一对应；参数用逗号隔开
public People(String name,int age,String eye){
    //完成初始化：this。属性 = 参数；
    this.name = name;
    this.age = age;
    this.eye = eye;
}
// alt + insert
public People(String name,int age,String eye,String nose, String hand){
    //调用自己的构造器，完成初始化
    this(name,age,eye);
    this.nose = nose;
    this.hand = hand;
}
```

构造器的调用

```
//this -》代表创建的那个对象
People p = new People();
People p1 = new People("WQH",21,"黑");
People p2 = new People("WQH",22,"黑","bizi","yisuang");
```

## 方法

```
//  pbulic 公有的方法，表示在任何地方，通过所属类的实例，方法名即可访问
//  void 无返回值   不能出现return 返回值，可以有return；
//	方法只有被调用才会执行
```

#### 值传递&&引用（地址）传递的区别

都在不同的方法区

值传递：在不同的空间，地址没有改变，所以调用后值也没变。实参把它的值传递给对应的形参，函数接收的是原始值的一个copy，**内存中存在两个相等的基本类型，即实参和形参**，**后面方法中的操作都是对形参的修改，不影响实际参数的值**。

引用（地址）传递：指向同一个地址；只要一个发生变化，则都会变化。实参的引用(地址，而不是参数的值)被传递给方法中相对应的形参，函数接收的是原始值的内存地址；在方法执行中，**形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象**。

```
public static void main(String[] args){
	int x = 20;//常量在堆里
    fd.test02(x);
    System.out.println("x = " + x);//x = 20;
    People p = new People("WQH",22,"黑","bizi","yisuang");
    fd.test02(p);
    System.out.println("name = " + p.name);//name = QAZ
}
 //值传递
public void test02(int x){
     x = 10;//在栈里
}
//引用（地址传递）
public void test02(People p){
p.name = "QAZ";
}
```



```
// ...：表示可变长度的参数（0-任意个），可以理解为数组
// ...的参数必须在参数列表的最后一个
public void test03(String a,int b, String... args){
      System.out.println( a + b);
      System.out.println(args.length);
      System.out.println(args[0]); //报数组越界异常
      for (String info : args) {
         System.out.println(args[0]);//正常
         System.out.println(info);
      }
}
```



**带返回值的传递：**

```
/**
     * @return 返回值类型：写什么类型，就返回什么类型
     */
    public String test04(){
        //String：一旦定义好之后，不可变，强调的是值内容不可变；
        //        如需再次定义，就会开辟一个新空间。
        //具有基本数据类型值传递的特点 8种包装类
        String a = "abc";
        a = "abcd";
        return "abcdefghijklmnopqrstuvwxyz";
    }
    public String test05(String a){
        return "ABC";
    }
```

```
// private只能在当前类中可以访问
private String sname;
// public 在任何地方通过实例。属性名称皆可以访问
public int age;
//default 没加任何修饰符，同包下可以访问
String address;
//子类（继承）中能访问/包访问权限
protected String sno;
//public    protected   default     private
```



## 三大特征：封装、继承、抽象

### 封装（Encapsulation)

​	将客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

### 继承（Inheritance/extends）

**单继承**：直接父类只能有一个

**间接父类**实现继承多个类

**super：**

```
//子类构造器默认会调用父类无参数的构造器
    //当创建子类对象，Bird时，会递归创建父类对象
    //没有显示指定调用父类的哪个构造器，则默认会调用父类无参数的构造器
    public Bird(){
        System.out.println("Bird");
        //this 当前类的实例
        //super 父类的实例
    }
```

### 重写 && 重载 针对的是方法

#### 重载

//同一个类中方法可以重名，但是参数列表必须要,称为方法的重载：

​		方法名相同,方法参数的个数和类型不同,通过个数和类型的不同来区分不同的函数;

​		方法的重载跟返回值类型和修饰符无关

```
public void test01(){
     System.out.println("test01");
}
public void test01(String name){
  //此处 + 表示字符串的拼接
  System.out.println("test01" + name);
}
```

#### 重写

```
/**
 * 子类对父类方法的重写，实现子类的逻辑
*/
@Override   //重写，
```

```
//父类
class People{
	public 
	public void sleep(){
		System.out.println("睡觉")
	}
	public void say(String info){
		System.out.println("say" + info)
	}
	//Object是所有类的间接或直接父类
}
//子类
public class Student extends People {
	//方法名相同，形参列表相同	两同
	//返回值相同，或更小（父类Object -》子类String）
	//抛出的异常更小或相同	两小
	//访问控制权限相	同或更大	一大
	//按照方法声明从前往后记忆
	修饰符 返回类型 方法名（）{}
	@Override
	public void sleep(){
		System.out.println("睡觉")
	}
	// alt + insert
	@Override
	public void say(String info){
		System.out.println("Happy to say" + info)
	}
	
}
```

### 多态（Polymorphism）

```
public class Animal {
	public String name;
	public int age;
	public void say(){}
}

public class Wolf extends Animal{
	@Override
	public void say(){
		System.out.print("┗|｀O′|┛ 嗷~~。。");
	}
}

public class Cat extends Animal{
	@Override
	public void say(){
		System.out.print("喵。..;
	}
}

public class Pig extends Animal{
	@Override
	public void say(){
		System.out.print("哼。。。。");
	}
}

public class Main{
	public static void main(String[] args){
		//父类引用指向子类实例，当调用同名方法时表现出不同的行为
		Animal cat = new Cat();
		cat.say();
		
		Animal pig = new Pig();
		cat.say();
		
		Animal wolf = new Wolf();
		cat.say();
		
		say(cat);
		say(pig);
		say(wolf);
	}
	
	public static void say(Animal animal){
		animal.say();
	}
}
```

has - a	：拥有，组合

is - a 		：表示子类时父类的一种

```
public class Worker{
	public void flushWall(){
		System.out.println("刷强")
	}
	public void installDoor(){
		System.out.println("安装门")
	}
}
public class House{
	private Worker	worker;

}

public class Main{
	public static void main(String[] args){
		House house = new House();
		Worker worker = new Worker();
	}
}
```

### 抽象（Abstract）



```
/**
 * 抽象类
 *      abstract 修饰
 *      以前在类中可以做的事情，在抽象类里面都能做
 *      可以定义抽象方法
 *		不能被实例化
 *  
 *  抽象方法
 *      abstract 修饰
 *      只声明，不实现
 */
public abstract class AbstractDemo {    //类
    public abstract void test();    //方法
}
```

##### 抽象类的使用

```
public abstract class BaseDbConn {
    //当前所使用的数据库名称
    private String name;
    //抽象类中构造器是用来初始化属性的，不是用来创建对象/实例的
    //抽象类没有对象/实例
    public BaseDbConn(String name) {
        this.name = name;
    }
    /*public BaseDbConn() {
    }*/
    //现实中有等数据库，他们获取连接（跟数据库建立通信）的方式存在差异
    //基类中定义一个获取连接的抽象方法，由不同的子类去实现
    public abstract Connection getConnection();
    //可以创建其他方法
    public void test(){
    }
    public String demo(){
        return "123";
    }
}
```



```
import java.sql.Connection;
/**
 *继承普通类： 继承父类的所有属性与方法
 * 继承抽象类：继承普通类 + 实现抽象类的所有抽象方法
 */
public class MysqlConn extends BaseDbConn{
    //默认调用抽象弗雷德空构造器完成信息
    //也可以指定调用父类的那个构造器
    public MysqlConn(String name){
        //调用父类指定的构造器
        //只要不指定，默认调用父类空构造器
        super(name);//父类有参构造器
        //super();//父类空构造器
    }
    @Override
    public Connection getConnection() {
        System.out.println("Mysql数据库");
        return null;
    }
}
```



```
/**
 * 抽象类不一定包含抽象方法
 * 包含抽象方法的类一定是抽象类
 * 继承自抽象类，但是不实现其中的抽象方法，那么这个类一定是抽象类
 * 包含抽象方法的不一定是抽象类，有可能是接口
 * 接口中的方法都是抽象方法
 */
public abstract class DemoConn extends BaseDbConn{

    public DemoConn(String name){
        //调用父类指定的构造器
        //只要不指定，默认调用父类空构造器
        super(name);//父类有参构造器
        //super();//父类空构造器
    }
}
```

### 接口（interface）



```
/**
 * 抽象类关键字：abstract
 * 接口关键字：interface
 *
 * 默认：接口里面的方法都是抽象的方法    public abstract修饰
 *       接口里面的变量都是常量，并且都是静态的，public static final修饰常量
 *
 *       共同的行为（方法）规范
 *       规范与实现分离
 */
public interface Beautiful {
    int x = 10;
    //描述当前接口的信息，可加可不加
    String describe = "接口的demo";
    //都是抽象方法，一套规范
    public abstract void demo();
    public abstract void test();
}
```



```
/**
 * 类的继承：单继承，一个类只能由一个直接父类
 * 接口继承：支持多继承   子接口会继承夫接口的所有抽象方法，与变量。。。
 * 接口实现：多实现，用逗号隔开
 */
public interface Flower extends Beautiful,Color{

}
```



```
/**
 * 接口是用来被实现的
 * 接口里的方法都是抽象方法，一个类如果实现了接口，就要实现里面所有的抽象方法
 * 否则可以把当前类定义成抽象类
 */
public class FlowerImpl implements Flower{
    @Override
    public void demo() {
    }
    @Override
    public void test() {
    }
}
```









## 单例模式

方法调用才被执行，对象 new时才会创建

```
/**
 * 懒汉式单例：始终只有一个实例  是非线程安全，高并发场景下
 *      可能会程序创建多个实例的问题，可以通过线程同步机制解决
 */
public class InstanceDemo {
    //静态变量  生命周期与类共存亡
    static InstanceDemo instanceDemo = null;
    //如果一个类没有显示给予构造器，则默认提供空构造器
    // public 任何地方都可以访问
    // private 只能在当前类中访问，不能在外部直接通过 new创建实例
    //如果创建实例，则必须在当前类中通过new创建
    private InstanceDemo(){

    }
    //没有static修饰，称为实例方法，实例。方法名
    //static修饰的方法称为静态方法   类名。方法名
    //静态内容的加载在非静态之前
    public static InstanceDemo getInstace(){
        if(instanceDemo == null){
            instanceDemo = new InstanceDemo();
        }
        return instanceDemo;
    }
```

```
/**
 * 饿汉式单例：始终只有一个实例
 */
public class InstanceDemo2 {
    //一开始就创建实例
    private static InstanceDemo2 instanceDemo2 = new InstanceDemo2();

    private InstanceDemo2(){

    }

    public static InstanceDemo2 getInstanceDemo2(){
        System.out.println("饿汉式单例！");
        return instanceDemo2;
    }
```

```
public class Main {
    public static void main(String[] args) {
        //一个类可以创建多个实例
        //单例;
        //加载InstanceDemo类，程序不结束，该类会一直在内存中（JVM）
        InstanceDemo id = InstanceDemo.getInstace();
        InstanceDemo id1 = InstanceDemo.getInstace();
        System.out.println(id.toString());
        /**
         * com.train.day05.InstanceDemo@1540e19d
         * com.train.day05.InstanceDemo@1540e19d
         */
        System.out.println(id1.toString());
        System.out.println("----------------------------------");

        //饿汉式单例
        InstanceDemo2 id2 = InstanceDemo2.getInstanceDemo2();
        System.out.println(id.toString());
        /**
         * com.train.day05.InstanceDemo@1540e19d
         * com.train.day05.InstanceDemo2@677327b6
         */
        System.out.println(id2.toString());
    }
}
```

**适用场景： 1.需要生成唯一序列的环境**

​                     **2.需要频繁实例化然后销毁的对象。**

​                     **3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。** 

​                     **4.方便资源相互通信的环境**
**优点：1.实现了对唯一实例访问的可控**

​               **2.对于一些需要频繁创建和销毁的对象来说可以提高系统的性能。**

 **缺点：1. 不适用于变化频繁的对象               **

​			**2.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出。**

​            **3.如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失。**

## final

```
public class FinalDemo {
    public int b;
    // 静态final变量
    public static final int a ;
    // 静态代码块
    static {
        a = 10;
    }
    public final int c;
    // 普通代码块
    {
        c = 20;
    }
    public final int d;
    // 构造器
    public FinalDemo(){
        d = 10;
    }

    // int 类型的包装类   int整型的对象/引用类型
	//    Integer
}
```



```
/**
 * final 类中的方法默认都是final的
 *       不能被继承
 * final方法；
 *    不允许其子类覆盖（重写）某个方法，但可以被继承
 *        普通类A中包含final方法
 *        普通类B extends A，B中会继承A的Final方法，但是不能重写
 *    提高效率
 *    不能用于修饰构造器
 * final 变量
 *     一旦初始化之后就不可以修改，普通变量：直接赋值；代码块；构造器
 *                                 静态变量；直接赋值；静态代码块
 * final类：String 8种基本数据类型的包装类...
 *
 */
public class FinalDemo1 {
    //final修饰的变量，初始化之后就不可以改变
    public static final int a = 10;

    public static void main(String[] args) {
        //试图修改final修饰的变量，就会报错
        //a = 20;

        final Japan japan = new Japan();
        japan.setAge(10);
        japan.setShape("small");
        //final 修饰的引用变量，对象引用不可变，不是对象的属性内容不可变
        //japan = new Japan();//Cannot assign a value to final variable 'japan'

    }

}
```

