Java程序由JVM执行，所以其内存区域划分的时候就是指JVM区域划分。

Java源码文件(.java)编译生成字节码文件（.class），然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作Runtime Data Area（运行时数据区），也就是JVM内存。因此，在Java中说到的内存管理就是针对这段空间进行管理。

### 存储区域

#### 寄存器

**最快的存储区**，保存的是程序当前执行的指令地址，执行结束后，自动获取下一天指令，位于CPU处理器内部。数量极其有限，由编译器根据需求进行分配。java中，**不能直接控制**，也不能在程序中感觉到寄存器存在的任何迹象。

**了解：**CPU 1.80GHz（Hz是单位）即CPU运算时的工作频率（1秒内发生的同步脉冲数）的简称。从理论上讲CPU的主频越高，它的速度也就越快，因为频率越高，单位时钟周期内完成的指令就越多，从而速度也就越快了.

#### 栈

存放基本类型的变量数据和对象的引用。速度仅次于寄存器。创建程序时候，JAVA编译器必须知道存储在栈内所有数据的确切大小和生命周期。**当线程执行一个方法时，就会随之创建一个对应的栈帧，即每个方法在执行的同时都会创建一个栈帧**，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。栈帧：局部变量表，方法返回地址等



#### 堆

用来存储**所有new出来的对象。**关于空间释放，Java的垃圾回收机制会自动进行处理，因此这部分空间也是Java垃圾**收集器管理的主要区域**。在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new，一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代价。**用堆进行存储分配比用栈进行存储需要更多的时间**。另外堆是被所有线程池共享的，在**JVM中只有一个堆**。当申请不到空间时会抛出 OutOfMemoryError（内存溢出），可使用无限循环不断新建对象，添加到集合中，最终会导致内存溢出.

**拓展：**内存泄漏主要是一个对象已经不再需要使用，但却被另一个对象持有时，就有可能发生内存泄漏。比如在方法内一个对象被全局的HashMap持有，方法执行结束没有释放就会导致内存泄漏。

**注意：**在JDK1.6之前，字符串常量池一直放在方法区中，但是到jdk1.7的时候，常量池便被移出方法区，转到Java堆中了

栈与堆的比较

- 栈(stack)与堆(heap)都是Java用来在Ram（random-access memory）中存放数据的地方。 
- 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢 。

#### 方法区/静态存储区

各个线程共享的区域，存放程序运行时一直存在的数据，存储已被虚拟机加载的每个类的信息（包括类的名称、方法信息、字段信息）静态变量（static修饰的成员变量）、常量、编译器编译后的代码（class文件）等。

#### 常量存储区

声明为final的为常量，保存在常量储存区，还有String类型的对象都是常量，系统维护了一个**String常量池**，常量池存储在方法区中。







