# 类加载

## 概述

类加载时机

-  第一次使用某个类时加载
- 预加载机制来加载

**JVM与程序：**用Java命令运行某个Java程序时，这个命令会启动一个Java虚拟机进程，这个进程中可能会有很多的线程，但这些线程都处于该Java虚拟机进程中。

JVM进程可能被终止的情况：

- 程序正常结束
- 程序运行到使用**System.exit**()**或**Runtime.getRuntime**().exit()**代码处结
- 程序运行中有未处理的异常或错误
- 程序所在平台强行结束**JVM**进程

```
public class Demo {
    public static int a = 10;
}
```

```
public class Test1 {
    public static void main(String[] args) {
        Demo.a ++;
        System.out.println(Demo.a); //结果？ 11
    }
}
```

```
public class Test2 {
    public static void main(String[] args) {
        System.out.println(Demo.a); //结果？ 10
    }
}
```

启动运行是两个JVM进程



程序使用要使用某个类时，如果该类还没有被加载到内存中，则系统会通过下面3个步骤（JVM连续完成）完成类加载或类初始化:

1. 加载
2. 连接
3. 初始化

## 类的加载

**类加载：**就是把类的class文件读入内存，同时为这个class创建一个java.lang.Class对象（普通类的类）

类：是某一类对象的抽象(概念)，其实类也是一种对象,如:

```
Class.forName(driver);
```

类其实都是java.lang.Class的实例，类的加载由JVM提供的类加载器完成，该加载器通常称为系统类加载器，我们可以通过**继承ClassLoader基类**来创建自己的类加载器

```
public class MyClassLoader extends ClassLoader{
  …….//自定义类加载逻辑  
}
```

类加载就是把.class文件读入内存

加载类的二进制数据的来源:

- 本地文件系统加载**class**文件
- 从**JAR**包加载**class**文件，如**JDBC**中的驱动就是放在**JAR**文件中的
- 通过网络加载**class**文件
- 把一个**Java**源文件动态编译，并加载

### 类加载器

加载器负责将.class文件加载到内存，并为之生成对应的java.lang.Class对象

- 如果一个类被载入JVM中，同一个类就不会被再次载入了。

-  JVM启动时，会形成由3个类加载器形成的初始类加载器层次结构:

  - Bootstap ClassLoader**:**根类加载器**,**负责加载**Java**核心类**,**它很特殊，它不是**java.lang.ClassLoader**的子类，而是由**JVM**自身实现的。
  - Extension ClassLoader**:**扩展类加载器**,**负责加载**JRE**的扩展目录**(%JAVA_HOME%/**jre**/lib/**ext或者由java.ext.dirs**系统属性指定的目录**)**中**JAR包的类
  - System ClassLoader:**系统类加载器**,**负责在**JVM**启动时加载来自**java**命令的**-**classpath**选项

  

## 类的连接

类加载-->生成对应的Class对象-->连接(主要负责把加载过来的二进制文件合并到JRE)

连接又分3阶段:

1. 验证**:**检查加载过来的类是否有正确的结构

2. 准备**:**为类的静态**Field**分配内存，并设置默认初始值

3. 解析**:**把类的二进制数据中的符号引用替换成直接引用

**符号引用:**以一组符号来描述所引用的目标, 符号可以是任何形式的字面量, 只要使用时能够无歧义的定位到目标即可. 例如, 在Java中, 一个Java类将会编译成一个class文件. 在编译时, Java类并不知道所引用的类的实际地址, 因此只能使用符号引用来代替. 比如org.simple.People类引用了org.simple.Language类, 在编译时People类并不知道Language类的实际内存地址, 因此只能使用符号org.simple.Language来表示Language类的地址.

**直接引用**:直接指向目标的指针.(如指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针)，相对偏移量. (指向实例的变量, 方法的指针)，一个间接定位到对象的句柄.

如果有了直接引用，那引用的目标必定已经被加载入内存中了。

## 类的初始化

初始化是由JVM负责，主要就是对静态Field进行初始化，静态Field指定初值两种方式:

- 声明时指定
- 使用静态初始化块为其赋值

```
public class Demo {
    static int a = 10;
    static int b;
    static int c;
    static {
        b = 20;
    }
}
```

```
public class Demo {
    public static int a = 10;
    static int c;
    static {
        b = 20;
    }
    // 定义b并为其赋值
    static int b = 15;
    public static void main(String[] args) {
        System.out.println(b); // 输出？ 15
    }
}
```

 JVM初始化类的步骤:

1. 如果这个类还没有被加载，则先加载并连接该类
2. 如果该类的直接父类还没有被初始化，则先初始化其直接父类
3. 如果该类中有初始化语句，则系统**依次执行**这些初始化语句

初始化时机

Java程序首次通过下面6种方式来使用某个类或接口时，系统会初始化该类或接口

​        1）创建类的实例，也就是new一个对象 
　　2）访问某个类或接口的静态变量，或者对该静态变量赋值 
　　3）调用类的静态方法 
　　4）反射（Class.forName(“com.train.HelloWorld”)） 
　　5）初始化一个类的子类（会首先初始化子类的父类） 
　　6）JVM启动时标明的启动类，即文件名和类名相同的那个类 

对于final修饰的静态Field，如果该Field的值在编译时就可以确定下来，那么这个Field相当于**宏变量**。这种情况下是不会初始化这个类的,反之如果编译时不能确定，那么就要初始化这个类

**类的加载与类的初始化是不同的，类加载不一定初始化，但类初始化之前这个类一定被加载**



初始化顺序

初始化顺序依次是：（静态变量、静态初始化块，按顺序加载）–>（变量、初始化块 按顺序加载）–> 构造器->静态方法；

```
public static String info = "name";
    static {
        System.out.println("static block");
        // info写到静态代码块的下面会报错
        System.out.println(info); 
    }

    public  String infoNormal = "name";
    {
        System.out.println("normal block");
        // infoNormal写到代码块的下面会报错
        System.out.println(infoNormal);
    }
    
    public static void test(){

    }
    public InitClass(){
        test();// 正常执行，不报错
    }
```

带有继承时

**父类的静态代码块->子类的静态代码块->初始化父类的属性值/父类的普通代码块(自上而下的顺序排列)->父类的构造方法->初始化子类的属性值/子类的普通代码块(自上而下的顺序排列)->子类的构造方法。**

[参考网站](<https://www.jianshu.com/p/202f6abb229c>)