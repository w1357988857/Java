# 反射

Java程序对象类型:

- 编译时类型  
- 运行时类型

```
Person p=new Student(); 
```

p译时是Person类型，而运行时是Student类型

**如何解决这个编译时与运行时的类型不同呢?**

1. 假设在编译时和运行时都完全知道类型的具体信息，这种情况下用instanceof判断，再进行强制转换实现

2. 第二种做法:编译时根本无法预知该对象和类可能属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，这就必须使用**反射**

获得Class对象

我们知道类加载后，系统会生成此类的java.lang.Class对象，通过该Class对象就可访问JVM中的这个类。Java程序中获得Class对象通常用如下3种方式:

- 使用**Class**类的**forName**(String className**)**静态方法。**className**包含完整包名与类名
- 调用某个类的**class**属性来获取该类对应的**Class**对象，如 Person.class**将会返回**Person**类对应的**Class对象
- 调用某个对象的**getClass**()**方法。这个方法是**Object**类中的一个方法**,**它会返回该对象所属类对应的**Class对象

在获得了某个类所对应的Class对象后，程序就可以调用Class对象的方法来获得该对象和该类的真实信息了。

获取Class对象对应类的所包含的构造器

![](img/01.png)

获取Class对象对应类所包含的方法

![](img/02.png)

获取Class对应类所包含的Field

![](img/03.png)

获取Class对象对应类的相关类、接口等

![](img/04.png)

获取Class对象对应类的修饰符、所在包、类名等基本信息

![](img/05.png)

判断该类是否为接口、枚举类型等

![](img/06.png)

使用反射生成并操作对象

通过反射来生成对象有如下两种方式

  1.**使用**Class**对象的**newInstance**()**方法来创建该**Class**对象对应类的实例，这种方式要求该**Class**对象的对应类有默认构造器，执行**newInstance**()方法时实际上就是利用默认构造器创建该类的实例

  2.**先使用**Class**对象获取指定的**Constructor**对象，再调用**Constructor**对象的**newInstance**()**方法来创建该**Class**对象对应的实例。通过这种方式可以选择使用指定的构造器来创建实例

  前一种方法较常见，很多JavaEE框架中都需要根据配置文件信息来创建Java对象，从配置文件中读取的只是某个类的字符串类名，程序需要根据该字符串来创建对应的实例，就必须使用反射

**调用方法**

获得某个类对应的Class对象后，就可以通过该Class对象的getMethods()方法或getMethod()方法来获取全部方法或指定方法，前一个方法是返回一个Method数组，后者是Method对象

Method对象对应一个方法，获得Method对象后，程序就可以通过该Method来调用它对应的方法。在Method里包含一个invoke()方法，方法的签名如下:

Object invoke(Object obj,Object...args):obj是执行该方法的主调，后面的args是参数。

**操作数组**

java.lang.reflect包下提供了一个Array类，Array对象可以代表所有的数组，程序可以通过使用Array来动态地创建数组，操作数组元素等

Array提供了如下几个方法:

static Object newInstance(Class<?>componentType,int**... length):**创建一个具有指定元素类型、指定维度的新数组

static xxx getXxx**(Object **array,int index):**返回**array**数组中第**index**元素，如果数组元素是引用类型，则该方法变为**get(Object array,int index);

static void setXxx(Object array,int index,xxx val**):**将**array**数组中第**index**元素值设定为val

如果数组元素是引用类型，则该方法变为set(Object array,int index,Object);

