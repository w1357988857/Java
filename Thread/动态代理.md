# 动态代理

## 概述

动态代理的意义在于生成一个**占位**（又称代理对象），来**代理真实对象**，从而**控制真实对象的访问**。

场景：假如你是一家软件公司的软件工程师，客户带着需求去找公司显然不会直接和你谈，而是去找商务谈，此时客户会认为商务代表公司。

客户通过商务去访问软件工程师，那么商务对象的意义在什么地方呢？

客户可以进行谈判，如项目启动前的商务谈判，软件的价格，交付，进度的时间节点等，或者项目完成后的商务追讨，应收账款等。商务也有可能在开发之前谈判失败，此时商务就会根据公司规则去结束和客户之间的合作关系，这些都不用软件工程师来处理。

因此，**代理的作用就是，在真实对象访问之前或者之后加入对应的逻辑，或者根据其他规则控制是否使用真实对象**，正如上例中商务控制了客户对软件工程师的访问。

经过上面的论述，我们知道商务和软件工程师是代理和被代理的关系，客户是经过商务去访问软件工程师的。此时客户就是程序中的调用者，**商务就是代理对象，软件工程师就是真实对象**。

![07](E:\JAVA\JAVA基础\Thread\unit13-img\07.png)

我们需要调用者调用真实对象之前产生一个代理对象，而这个代理对象需要和真实对象建立代理关系，所以代理必须分为两个步骤

1. 代理对象和真实对象建立代理关系
2. 实现代理对象的代理逻辑方法

Java中有多种动态代理技术，如JDK，CGLIB，Javassist，ASM。常用的有两种，一是JDK动态代理，JDK自带的功能，二是CGLIB，第三方提供的技术（需要jar包）。Spring常用JDK和CGLIB，而mybatis还是用了Javassist，无论哪种代理技术，理念都是相似的。





## JDK 动态代理

Java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类与接口，可以生成JDK动态代理类或动态代理对象

**实现步骤**

1.先建立真实对象(被代理对象)，然后实现代理逻辑。

```
public interface IHelloWorld {
    public void sayHello();
}

public class HelloWorldImpl implements IHelloWorld{
    @Override
    public void sayHello() {
    System.out.println(HelloWorldImpl.class.getSimpleName() + ": sayHello");
}
}

```

2.JDK动态代理中要实现代理逻辑类，必须实现接口java.lang.reflect.InvocationHandler，其中定义了一个invoke方法，用于代理方法逻辑的实现。

```
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class JdkProxyExample implements InvocationHandler {
/**
 * 真实对象
 */
private Object target;// 软件工程师对象

/**
 * 建立真实对象和代理对象的关系
 * 建立商务和软件工程师的关系
 * @param target
 * @return 代理对象 -》商务对象
 */
public Object bind(Object target) {
    this.target = target;
    // target.getClass().getInterfaces()表示生成的代理对象下挂在那些接口下
    return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
}

// proxy 就是bind方法生成的对象
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    System.out.println("前");
    Object obj = method.invoke(target, args);// 真实对象方法调用，商务逻辑控制软件工程师的访问
    System.out.println("后");
    return obj;
}
}

```

3.主类运行

```
public static void main(String[] args) {
    JdkProxyExample jpe = new JdkProxyExample();
    // 被代理对象-真实对象 程序员
    HelloWorldImpl hwi = new HelloWorldImpl();
      // 绑定关系，存在下挂接口IHelloWorld
      // 代理对象- 商务对象
    IHelloWorld proxy = (IHelloWorld) jpe.bind(hwi);
    // 通过代理对象调用，进入代理逻辑方法invoke中
    proxy.sayHello();
}
```

## 动态代理设计

由于动态代理一般都比较难理解，程序设计者会设计一个拦截器接口供开发者使用，开发者只需要知道拦截器接口的方法、含义和作用即可，无需知道动态代理是怎么实现。

JDK动态代理来实现一个拦截器的步骤如下：

1、定义拦截器接口

```
Before 在方法被调用之前调用通知
After 在方法完成之后调用通知，无论方法执行是否成功
After-returning 在方法成功执行之后调用通知
After-throwing 在方法抛出异常后调用通知
```

2.定义接口

```
public interface IInterceptor {
/**
 * @param proxy 代理对象
 * @param target 真实对象
 * @param method 方法
 * @param args 运行方法参数
*/
    public boolean before(Object proxy, Object target, Method method,Object[] args);
    public void around(Object proxy, Object target, Method method,Object[] args);
    public void after(Object proxy, Object target, Method method,Object[] args);
}

```

3.定义接口实现类

```
public class MyInterceptor implements IInterceptor{
@Override
public boolean before(Object proxy, Object target, Method method, Object[] args) {
    System.out.println("反射方法前逻辑");
    return false;
}
@Override
public void around(Object proxy, Object target, Method method, Object[] args) {
	System.out.println("取代了被代理对象的方法");
}
@Override
public void after(Object proxy, Object target, Method method, Object[] args) {
    System.out.println("反射方法后逻辑");
}
}

```

4.建立JDK动态代理类

```
public class JdkProxyInterceptor implements InvocationHandler {

    // 真实对象
    private Object target;
    // 拦截器全限定名
    private String interceptorClass = null;

public JdkProxyInterceptor(Object target, String interceptorClass) {
    this.target = target;
    this.interceptorClass = interceptorClass;
}

/**
 * 绑定委托对象并返回一个（代理占位）
 * @param target 真实对象
 * @param interceptorClass 代理对象（占位）
 * @return
 */
public static Object bind(Object target, String interceptorClass){
// 取得代理对象
    return Proxy.newProxyInstance(target.getClass().getClassLoader(),
    target.getClass().getInterfaces(), this);
}
// new JdkProxyInterceptor(target, interceptorClass)

/**
 * 
 */
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (null == interceptorClass) {
        // 没有设置拦截器则直接反射原有方法
        return method.invoke(target, args);
    }

    Object result = null;
    // 通过反射生成拦截器
    IInterceptor interceptor = (IInterceptor) Class.forName(interceptorClass).newInstance();
    // 调用前置方法
    if(interceptor.before(proxy, args, method, args)) {
        // 反射原有对象方法
        result = method.invoke(target, args);
    } else {// 返回false执行around方法
    	interceptor.around(proxy, args, method, args);
    }
        // 调用后置方法
        interceptor.after(proxy, args, method, args);
        return result;
    }
}
```

5.main法调用

```

```

综上可知：

1. 开发者只要知道拦截器的作用就可以编写拦截器了，编写完后可以设置拦截器，这样就完成了任务，所以对于开发者而言相对简单了
2. 设计者可能是精通Java的开发人员，他来完成动态代理的逻辑
3. 设计者只会把拦截器接口暴露给开发者使用，让动态代理的逻辑在开发者的视野中“消失”







